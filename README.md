## 项目简介

本项目是一个基于 **PaddleOCR-json** 的桌面工具——**Umi-OCR 智能重命名助手**。  
它通过对两组图片（A 组、B 组）进行 OCR 文字识别与相似度匹配，将 **B 组图片自动重命名为 A 组对应的图片名称**，适用于：

- **批量图片归档**：如教材截图、试卷、文档扫描件等
- **截图整理**：自动按页面标题、章节名等文字内容进行匹配命名
- **多来源图片比对**：不同来源的同一组图片（例如手机拍照 vs 扫描仪）进行统一命名

识别核心由 `PaddleOCR-json_v1.4.1/PaddleOCR-json.exe` 提供，本项目的 Python 程序 `main.py` 负责：

- **启动和管理 OCR 引擎进程**
- **并发执行图片 OCR 识别**
- **对识别文本进行相似度匹配**
- **通过 PySide6 提供现代简约风格的图形界面**

---

## 项目构成

### 主要文件与目录

- **`main.py`**  
  - **应用主程序入口**：启动 PySide6 界面、初始化 OCR 引擎、管理业务逻辑。
  - **核心类**：
    - `OCRController`：负责启动/关闭 `PaddleOCR-json.exe` 子进程，发送图片路径、接收识别结果。
    - `OCRWorker`（QThread）：在后台线程中批量执行 OCR，并通过 Qt 信号将进度和结果发回 UI。
    - `ImageCard`：单张图片在 UI 中的展示组件（缩略图、文件名、尺寸、OCR 摘要、匹配状态）。
    - `OCRImageMatcher`（QMainWindow）：主窗口类，负责整体布局、交互逻辑和重命名流程。
  - **辅助函数**：
    - `get_base_dir()`：统一获取“脚本/EXE 所在目录”，兼容开发环境与打包后环境。
    - `resource_path()`：基于上面的根目录，构造资源（如 `PaddleOCR-json_v1.4.1`）的绝对路径。
    - `find_paddleocr_exe()`：在预设位置查找 `PaddleOCR-json.exe` 并校验 `models` 目录是否存在。
  - **程序入口**：
    - `main()`：创建 `QApplication`，设置样式、创建并显示主窗口。
    - `if __name__ == "__main__":` 中使用 `multiprocessing.freeze_support()` 以兼容 PyInstaller `--onefile`。

- **`PaddleOCR-json_v1.4.1/`**  
  - **`PaddleOCR-json.exe`**：本地 OCR 引擎（无需联网），由本项目的 `OCRController` 调用。
  - **`models/`**：各语言的 OCR 模型与配置、字典文件：
    - `ch_PP-OCRv3_det_infer/`：中文文本检测模型  
    - `ch_PP-OCRv3_rec_infer/`：中文文本识别模型  
    - `ch_ppocr_mobile_v2.0_cls_infer/`：方向/分类模型  
    - 其他语言模型（英文、日文、韩文、繁体中文、俄文等）  
    - `dict_*.txt`：对应语言的字符字典  
    - `config_*.txt`：对应语言/配置的识别参数
  - **运行依赖 DLL**：如 `paddle_inference.dll`, `onnxruntime.dll`, `opencv_world4100.dll` 等，供引擎调用。

- **`README.md`**  
  - 当前文档，详细说明：项目背景、功能、使用方法、打包/发布流程、内部原理与常见问题。

- **`.gitignore`**  
  - Git 忽略配置，排除：
    - Python 缓存目录：`__pycache__/`, `*.pyc` 等  
    - 虚拟环境目录：`venv/`, `.venv/`, `env/` 等  
    - 打包产物：`build/`, `dist/`, `*.spec`  
    - IDE 配置与临时文件：`.vscode/`, `.idea/`, `*.log`, `*.tmp`, `*.bak` 等

- **`UmiOCR-Rename.spec`（可选存在）**  
  - PyInstaller 自动生成的打包配置文件：
    - 记录入口脚本、打包模式（onefile/onedir）、附加数据、图标等设置。
    - 可以用 `pyinstaller UmiOCR-Rename.spec` 按相同配置重新打包。
  - 本仓库默认通过 `.gitignore` 忽略该文件，如需固定打包配置，可手动将其纳入版本控制。

- **`build/`（打包时自动生成）**  
  - PyInstaller 的中间构建目录，保存临时文件和分析结果，对最终运行不必要。
  - 可以随时删除或忽略，不建议提交到 Git。

- **`dist/`（打包输出目录）**  
  - 存放最终生成的可执行文件：
    - `UmiOCR-Rename.exe`：打包后的独立 EXE。
    - `PaddleOCR-json_v1.4.1/`：发布时需要手动复制到此目录，与 EXE 同级。
  - 可以整体压缩并分发给用户使用。

- **`venv/`（推荐）**  
  - 本项目建议的 Python 虚拟环境目录（通过 `python -m venv venv` 创建）。
  - 用于隔离依赖版本，确保打包环境干净、可复现。

- **`__pycache__/`**  
  - Python 运行时自动生成的字节码缓存目录，可忽略，不纳入版本控制。

---

## 核心依赖与运行环境

- **操作系统**：Windows 10 / 11（本项目当前主要针对 Windows 平台）
- **Python**：建议 Python 3.8 及以上
- **主要依赖库**：
  - **PySide6**：用于图形界面（窗口、按钮、列表、卡片等）
  - **Pillow (PIL)**：用于图片读取和格式转换（例如将 `avif`/`heic` 等不支持格式转为 PNG）
  - **fuzzywuzzy**（可选）：用于更精确、灵活的文本相似度匹配  
    - 如果未安装，将自动回退使用 `difflib` 进行备选匹配（控制台会提示警告）。
  - **标准库**：`os`, `sys`, `time`, `tempfile`, `pathlib`, `subprocess`, `json`, 等。

> **说明**：请根据你当前环境，将实际使用到的第三方库加入 `requirements.txt`（若你计划分享或部署此项目）。

---

## 功能概述

- **双文件夹智能重命名**
  - 选择 **A 组文件夹**：一般为“标准命名”的图片集合，名称已正确或代表目标命名方式。
  - 选择 **B 组文件夹**：名称混乱或无意义（如随机截图名）的图片集合。
  - 程序通过 OCR 分别识别 A、B 两组图片中的文字内容，计算文本相似度，将 **B 组图片重命名为与最相似的 A 组图片名称**。

- **OCR 智能识别**
  - 基于 PaddleOCR 模型，支持多语言文字识别。
  - 对不被原生支持的图片格式（如 `.avif`, `.heic`, `.heif`）尝试自动转换为 PNG 后再识别。
  - 每张图片识别完成后，界面会实时更新 **进度状态** 与 **文字摘要**。

- **现代化图形界面（PySide6）**
  - 窗口布局采用现代简约风格，提供卡片式图片展示。
  - 每张图片对应一张 `ImageCard`：
    - 顶部带有删除按钮，可快速从任务中移除该图片。
    - 中间显示统一大小的图片缩略图。
    - 底部显示文件名、尺寸信息与少量 OCR 文本摘要。
    - 还支持显示匹配状态的小角标（例如匹配成功/失败）。

- **多线程与实时进度显示**
  - 使用 `OCRWorker`（QThread）在后台进行识别，避免阻塞界面。
  - 主线程通过 Qt 的 `Signal` / `Slot` 将每张图片的进度、状态同步到界面：
    - “正在识别 x/y”
    - “识别完成 √”
    - “识别失败 ✗” 等。

- **识别结果管理与重命名**
  - 为每张图片记录 OCR 文本结果。
  - 对 A/B 两组图片的文本结果进行相似度计算（优先使用 `fuzzywuzzy`，否则用 `difflib`）。
  - 自动生成重命名方案并在界面中展示，用户可以检查后执行（具体交互细节以实际 UI 为准）。

---

## 使用说明

> 以下为典型使用流程示例，具体按钮名称与布局请以实际界面为准。

### 1. 启动程序

在项目根目录下执行：

```bash
python main.py
```

如果使用虚拟环境，请先激活对应虚拟环境，再运行上述命令。

程序启动后会弹出主窗口，界面左/右侧分别用于 A 组、B 组文件夹或图片列表展示。

### 2. 选择图片文件夹

- **选择 A 组文件夹**
  - 点击界面中类似“选择 A 组文件夹”/“选择参考图片目录”的按钮。
  - 在系统文件对话框中选中对应的文件夹。
  - 成功后，A 组图片会以 `ImageCard` 形式加载到界面中。

- **选择 B 组文件夹**
  - 点击类似“选择 B 组文件夹”/“选择待重命名目录”的按钮。
  - 选中包含待重命名图片的目录。
  - B 组图片同样以卡片形式显示。

> 某些版本可能支持拖拽图片/文件夹到窗口中，请根据实际界面提示操作。

### 3. 启动 OCR 识别

- 在 A 组图片加载完成后，点击类似“开始识别 A 组”或“一键识别”的按钮即可。
- 程序将：
  - 启动或复用 `PaddleOCR-json.exe` 进程；
  - 逐张图片发送识别请求；
  - 在界面底部或侧边栏实时显示识别进度。

对 B 组同理，可以分别或统一触发识别。

### 4. 检查识别结果与匹配关系

- 在每张图片对应的 `ImageCard` 上可以看到：
  - 缩略图
  - 文件名
  - OCR 文本摘要（前若干字符）
  - 匹配状态角标（若已完成匹配/对齐）
- 在主界面中，通常会有 **列表/表格** 显示匹配结果，例如：
  - `A组图片名` ↔ `B组图片名（建议新名称）` ↔ `相似度分数`
- 建议在执行真正的重命名前，浏览一遍匹配结果，确认是否符合预期。

### 5. 执行重命名

- 当你对匹配方案满意后，可以点击类似“应用重命名”/“开始重命名”的按钮。
- 程序会按照匹配关系将 **B 组图片的文件名改为 A 组对应图片名**（可能附加序号或保留扩展名等，视实际实现而定）。
- 完成后，界面会提示重命名结果。

> **注意**：重命名操作具有不可逆性，建议事先备份重要文件，或在测试目录中先尝试。

---

## 内部工作原理（简述）

### 1. OCR 引擎调用流程

- 程序使用 `subprocess.Popen` 启动 `PaddleOCR-json.exe`：
  - `stdin`、`stdout` 管道用于与引擎通信。
  - 工作目录设置为 `PaddleOCR-json_v1.4.1`，保证模型、DLL 能正常加载。
  - 在 Windows 上通过 `STARTUPINFO` 隐藏命令行窗口。

- 启动后，程序会等待标准输出中出现 `"OCR init completed."` 或 `"初始化完成"` 这类提示，确保引擎就绪。

- 对每张待识别图片：
  - 先通过 `convert_image_if_needed` 判断是否需要格式转换（如 `.avif`, `.heic` 等）。
  - 将图片路径打包为 JSON：`{"image_path": "实际路径"}`，写入引擎的 stdin。
  - 读取 stdout 的一行 JSON 结果，解析 `code` 字段与 `data` 中的 `text` 字段，组合成最终文本。
  - 对临时转换出的 PNG 文件，使用完后尝试删除，避免缓存堆积。

### 2. 多线程识别与 UI 更新

- `OCRWorker` 继承自 `QThread`：
  - 在其 `run()` 方法中遍历图片列表：
    - 每处理一张图片，会通过 `progress` 信号向主线程发送：
      - 当前图片路径
      - OCR 文本（或空字符串表示“正在识别中”）
      - 状态描述（如“正在识别 A 组: 1/10 ...”）
  - 完成全部图片后通过 `finished` 信号通知主界面。
  - 支持中途中断（例如窗口关闭时）通过 `isInterruptionRequested()` 安全退出。

- 主线程中，相关槽函数会：
  - 更新 `ImageCard` 显示的文本摘要与状态。
  - 刷新整体进度条、日志面板等。

### 3. 模糊匹配逻辑

- 优先尝试导入 `fuzzywuzzy` 库并将 `FUZZYWUZZY_AVAILABLE` 置为 True。
- 如果导入失败，则打印一条警告信息，并使用 Python 标准库中的 `difflib` 作为备选方案。
- 在 A/B 两组图片都识别完成后：
  - 对每张 B 组图片的 OCR 文本，与所有 A 组文本计算相似度得分。
  - 选取分数最高且（可能）高于某个阈值的 A 组作为匹配对象。
  - 将该 A 组图片名作为 B 组图片的目标新名称。

---

## 打包为独立 EXE（发布说明）

采用 **“半独立打包”方案**：**1 个 GUI EXE + 1 个 OCR 文件夹**，即：

- `UmiOCR-Rename.exe`
- `PaddleOCR-json_v1.4.1\`（与 exe 同级，保持完整原始结构）

### 1. 准备打包环境

在项目根目录执行：

```bash
python -m venv venv
venv\Scripts\activate
python -m pip install --upgrade pip
pip install pyinstaller PySide6 pillow fuzzywuzzy python-Levenshtein
```

> **说明**：`python-Levenshtein` 用于加速 `fuzzywuzzy`，大幅提高相似度计算性能。

### 2. 打包命令

在已激活虚拟环境、当前目录为项目根目录时执行：

```bash
python -m PyInstaller --name "UmiOCR-Rename" --noconfirm --noconsole --onefile main.py
```

完成后，`dist` 目录中会生成：

- `dist\UmiOCR-Rename.exe`

### 3. 布置 OCR 引擎文件夹

将整个 `PaddleOCR-json_v1.4.1` 目录复制到 `dist` 目录下，形成结构：

```text
dist\
  ├─ UmiOCR-Rename.exe
  └─ PaddleOCR-json_v1.4.1\
      ├─ PaddleOCR-json.exe
      ├─ models\
      ├─ *.dll
      └─ ...
```

此时，可直接双击 `UmiOCR-Rename.exe` 使用，无需本地安装 Python。

### 4. 打包相关代码约定（已经在项目中实现）

- 使用 `get_base_dir()` 与 `resource_path()` 统一获取资源路径，保证：
  - 开发环境：从 `main.py` 所在目录查找；
  - 打包后：从 exe 所在目录查找。
- `find_paddleocr_exe()` 优先查找：
  - `PaddleOCR-json_v1.4.1\PaddleOCR-json.exe`
  - 以及同级 `PaddleOCR-json.exe`，并检查旁边存在 `models` 目录。
- 程序入口处使用：

```python
if __name__ == "__main__":
    import multiprocessing
    multiprocessing.freeze_support()
    main()
```

以兼容 Windows 下 PyInstaller `--onefile` 与子进程场景，避免异常自启动/多进程问题。

---

## 常见问题与排查

- **Q：程序提示找不到 `PaddleOCR-json.exe` 或模型文件？**  
  - **A**：请确认：
    - `PaddleOCR-json_v1.4.1` 目录完整存在于项目根目录；
    - 其中包含 `PaddleOCR-json.exe` 与 `models` 文件夹；
    - 没有随意移动/改名这些文件和目录。

- **Q：识别结果为空或乱码？**  
  - **A**：
    - 确认图片是否清晰、分辨率是否过低、文字是否过小或倾斜严重；
    - 检查是否使用了正确的语言模型和配置（中文 vs 其他语言）；
    - 查看控制台输出，确认 OCR 引擎是否报错。

- **Q：界面卡顿或无响应？**  
  - **A**：
    - 理论上，OCR 放在 QThread 中执行，主界面不应被阻塞；
    - 如果仍感觉卡顿，可能是：
      - 同步更新 UI 的频率过高；
      - 一次性加载的图片数量非常大；
    - 可尝试减少同时识别的图片数量或优化图片尺寸。

- **Q：重命名后文件丢失？**  
  - **A**：一般是被移动/重命名到同一目录下的新文件名，请在文件夹中按时间/名称排序查找。  
    - 建议重要文件先备份，在测试目录验证流程无误后再大规模使用。

---

## 许可证与致谢

- **本项目代码**：你可以根据自己意愿选择合适的开源协议（例如 MIT、Apache-2.0 等），并在此处进行说明。  
- **PaddleOCR-json 与模型文件**：  
  - 来自 PaddleOCR 相关项目及其衍生工具，遵循各自的开源协议。  
  - 使用时请遵守上游项目的授权条款与使用规范。

如需二次开发或集成到你的其他项目中，建议：

- **抽离 OCR 调用逻辑**（`OCRController` 等）为独立模块；
- **将 UI 层与业务层适当解耦**，方便替换前端或接入其他系统；
- 充分测试在不同分辨率、不同语言、不同图片质量下的识别效果与匹配准确率。

